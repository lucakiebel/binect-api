/* tslint:disable */
/* eslint-disable */
/**
 * Binect API REST
 * Webservice für den Briefversand. Ihre Briefe werden durch unser System ausgedruckt, kuvertiert, frankiert und zur Deutschen Post gebracht.  Für eine detaillierte Beschreibung schauen Sie bitte in das Modell. </br></br>Hinweis: Wenn Sie als Benutzer eingeloggt sind, laufen alle Anfragen gegen das Produktiv-System. </br>Somit stornieren, l&ouml;schen, ... oder versenden Sie Ihre Briefe wirklich!</br> Falls Sie Zugriff auf unser Testsystem ben&ouml;tigen, stellen Sie gerne eine Anfrage an kontakt@binect.de.
 *
 * The version of the OpenAPI document: 0.9.5-beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * account data
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'credit': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'promotionCredit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'creditLimit'?: number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Account
     */
    'unit': CurrencyEnum;
}
/**
 * Describe an action of a transaction
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * Following action codes are defined:   1 (is sent),    2 (is canceled),    3 (delivery error)  
     * @type {number}
     * @memberof Action
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'text': string;
}
/**
 * Adress.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'nameExtend'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'numberOfPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof Attachment
     */
    'newSheet': boolean;
    /**
     * This attachment appended to \'n\' documents
     * @type {number}
     * @memberof Attachment
     */
    'ntimesUsed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'remarks'?: string;
}
/**
 * The content of the file and file name. The content must be base64 encoded.
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * 
     * @type {string}
     * @memberof Content
     */
    'filename': string;
    /**
     * 
     * @type {any}
     * @memberof Content
     */
    'content': any;
}
/**
 * The coworkers data.
 * @export
 * @interface Coworker
 */
export interface Coworker {
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'debitornumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'registrationDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Coworker
     */
    'numberOfSendings'?: number;
    /**
     * 
     * @type {Price}
     * @memberof Coworker
     */
    'totalAmount'?: Price;
}
/**
 * 
 * @export
 * @interface CreateDocumentAttachmentRequest
 */
export interface CreateDocumentAttachmentRequest {
    /**
     * 
     * @type {Content}
     * @memberof CreateDocumentAttachmentRequest
     */
    'content': Content;
    /**
     * The Attachment will start on the front page of a sheet
     * @type {boolean}
     * @memberof CreateDocumentAttachmentRequest
     */
    'newSheet'?: boolean;
    /**
     * Remarks to the attachment
     * @type {string}
     * @memberof CreateDocumentAttachmentRequest
     */
    'remarks'?: string;
}
/**
 * 
 * @export
 * @interface CreateDocumentRequest
 */
export interface CreateDocumentRequest {
    /**
     * 
     * @type {Content}
     * @memberof CreateDocumentRequest
     */
    'content': Content;
    /**
     * 
     * @type {Options}
     * @memberof CreateDocumentRequest
     */
    'options'?: Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof CreateDocumentRequest
     */
    'attributes'?: Array<LetterAttribute>;
    /**
     * 
     * @type {CreateDocumentRequestSplitParams}
     * @memberof CreateDocumentRequest
     */
    'splitParams'?: CreateDocumentRequestSplitParams;
}
/**
 * If the uploaded document is a serial letter, define how it shall be split.
 * @export
 * @interface CreateDocumentRequestSplitParams
 */
export interface CreateDocumentRequestSplitParams {
    /**
     * This token is used to split the serial letter.
     * @type {string}
     * @memberof CreateDocumentRequestSplitParams
     */
    'splitToken'?: string;
    /**
     * Every N pages the serial letter is split.
     * @type {number}
     * @memberof CreateDocumentRequestSplitParams
     */
    'splitAfterNumberOfPages'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyEnum = {
    Eurocent: 'eurocent'
} as const;

export type CurrencyEnum = typeof CurrencyEnum[keyof typeof CurrencyEnum];


/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'numberOfPages'?: number;
    /**
     * 
     * @type {Status}
     * @memberof Document
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'documentType': DocumentDocumentTypeEnum;
    /**
     * 
     * @type {Letter}
     * @memberof Document
     */
    'letter'?: Letter;
    /**
     * 
     * @type {SerialLetter}
     * @memberof Document
     */
    'serialLetter'?: SerialLetter;
}

export const DocumentDocumentTypeEnum = {
    Letter: 'Letter',
    SerialLetter: 'SerialLetter'
} as const;

export type DocumentDocumentTypeEnum = typeof DocumentDocumentTypeEnum[keyof typeof DocumentDocumentTypeEnum];

/**
 * 
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * 
     * @type {number}
     * @memberof DocumentStatus
     */
    'id': number;
    /**
     * 
     * @type {Status}
     * @memberof DocumentStatus
     */
    'status': Status;
}
/**
 * 
 * @export
 * @interface ErrorParam
 */
export interface ErrorParam {
    /**
     * 
     * @type {string}
     * @memberof ErrorParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorParam
     */
    'value': string;
}
/**
 * Invoice.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'filename': string;
    /**
     * 
     * @type {Price}
     * @memberof Invoice
     */
    'totalAmount'?: Price;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface Letter
 */
export interface Letter {
    /**
     * 
     * @type {string}
     * @memberof Letter
     */
    'letterType': LetterLetterTypeEnum;
    /**
     * 
     * @type {LetterData}
     * @memberof Letter
     */
    'letterData'?: LetterData;
    /**
     * 
     * @type {Array<Error>}
     * @memberof Letter
     */
    'errors'?: Array<Error>;
}

export const LetterLetterTypeEnum = {
    LetterData: 'LetterData',
    Error: 'Error'
} as const;

export type LetterLetterTypeEnum = typeof LetterLetterTypeEnum[keyof typeof LetterLetterTypeEnum];

/**
 * 
 * @export
 * @interface LetterAttribute
 */
export interface LetterAttribute {
    /**
     * 
     * @type {string}
     * @memberof LetterAttribute
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof LetterAttribute
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface LetterData
 */
export interface LetterData {
    /**
     * 
     * @type {string}
     * @memberof LetterData
     */
    'recipientAddress': string;
    /**
     * 
     * @type {Price}
     * @memberof LetterData
     */
    'price': Price;
    /**
     * 
     * @type {boolean}
     * @memberof LetterData
     */
    'international': boolean;
    /**
     * 
     * @type {Options}
     * @memberof LetterData
     */
    'options': Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof LetterData
     */
    'attributes'?: Array<LetterAttribute>;
    /**
     * The Attachments which are appended to this document. </br>Only documents from documentType \'Letter\' can have attachments
     * @type {Array<Attachment>}
     * @memberof LetterData
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Binect error code.
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * Human readable error text with filled-in place holders.
     * @type {string}
     * @memberof ModelError
     */
    'text': string;
    /**
     * Text with place holders for parameters.  Place holders are framed in %-Symbols, e. g. \'error on page number %pageNr% of your document\'.
     * @type {string}
     * @memberof ModelError
     */
    'blankText': string;
    /**
     * Parameters for place holder in \'blankText\'.
     * @type {Array<ErrorParam>}
     * @memberof ModelError
     */
    'parameters'?: Array<ErrorParam>;
    /**
     * On which page of the document the error occurred.
     * @type {number}
     * @memberof ModelError
     */
    'errorOnPage'?: number;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * if false it is duplex
     * @type {boolean}
     * @memberof Options
     */
    'simplex': boolean;
    /**
     * if false it is black and white
     * @type {boolean}
     * @memberof Options
     */
    'color': boolean;
    /**
     * Shall only be used for \'C4\', otherwise not used. \'C4\' is the only supported value.
     * @type {string}
     * @memberof Options
     */
    'envelope'?: OptionsEnvelopeEnum;
}

export const OptionsEnvelopeEnum = {
    C4: 'C4'
} as const;

export type OptionsEnvelopeEnum = typeof OptionsEnvelopeEnum[keyof typeof OptionsEnvelopeEnum];

/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'priceBeforeTax': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'priceAfterTax': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Price
     */
    'unit': CurrencyEnum;
    /**
     * e. g. 19 for 19% sales tax
     * @type {number}
     * @memberof Price
     */
    'taxInPercent': number;
}
/**
 * 
 * @export
 * @interface SendDocumentRequest
 */
export interface SendDocumentRequest {
    /**
     * 
     * @type {Content}
     * @memberof SendDocumentRequest
     */
    'content': Content;
    /**
     * 
     * @type {Options}
     * @memberof SendDocumentRequest
     */
    'options'?: Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof SendDocumentRequest
     */
    'attributes'?: Array<LetterAttribute>;
}
/**
 * 
 * @export
 * @interface SerialLetter
 */
export interface SerialLetter {
    /**
     * This token is used to split the serial letter.
     * @type {string}
     * @memberof SerialLetter
     */
    'splitToken'?: string;
    /**
     * Every N pages, the serial letter is split.
     * @type {number}
     * @memberof SerialLetter
     */
    'splitAfterNumberOfPages'?: number;
    /**
     * 
     * @type {SerialLetterStatus}
     * @memberof SerialLetter
     */
    'status'?: SerialLetterStatus;
    /**
     * 
     * @type {Array<Document>}
     * @memberof SerialLetter
     */
    'letters'?: Array<Document>;
}
/**
 * 
 * @export
 * @interface SerialLetterStatus
 */
export interface SerialLetterStatus {
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrTotal': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrGenerated': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrSuccess': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrError': number;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Following status codes are defined:   1 (in preparation),    2 (is shippable),    3 (in production, waiting to be sent),    4 (in print process),    5 (is sent),    6 (is canceled),    7 (is erroneous)  
     * @type {number}
     * @memberof Status
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'text': string;
}
/**
 * Invoice.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * 
     * @type {Action}
     * @memberof Transaction
     */
    'action': Action;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'filename'?: string;
    /**
     * 
     * @type {Price}
     * @memberof Transaction
     */
    'amount'?: Price;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'numberOfPages'?: number;
    /**
     * 
     * @type {Options}
     * @memberof Transaction
     */
    'options'?: Options;
    /**
     * 
     * @type {Status}
     * @memberof Transaction
     */
    'status'?: Status;
    /**
     * Debitornumber of coworker
     * @type {string}
     * @memberof Transaction
     */
    'coworker'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentCoverpageRequest
 */
export interface UpdateDocumentCoverpageRequest {
    /**
     * 
     * @type {Address}
     * @memberof UpdateDocumentCoverpageRequest
     */
    'receivingAddress': Address;
    /**
     * 
     * @type {Address}
     * @memberof UpdateDocumentCoverpageRequest
     */
    'returnAddress'?: Address;
    /**
     * 
     * @type {UpdateDocumentCoverpageRequestCoverText}
     * @memberof UpdateDocumentCoverpageRequest
     */
    'coverText'?: UpdateDocumentCoverpageRequestCoverText;
}
/**
 * optional text on the cover page
 * @export
 * @interface UpdateDocumentCoverpageRequestCoverText
 */
export interface UpdateDocumentCoverpageRequestCoverText {
    /**
     * optional subject text on the cover page
     * @type {string}
     * @memberof UpdateDocumentCoverpageRequestCoverText
     */
    'subject'?: string;
    /**
     * optional date on the cover page
     * @type {string}
     * @memberof UpdateDocumentCoverpageRequestCoverText
     */
    'date'?: string;
    /**
     * Text on the cover page. Only plain text is supported. Start a new line with \'\\n\'.
     * @type {string}
     * @memberof UpdateDocumentCoverpageRequestCoverText
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentTransformationRequest
 */
export interface UpdateDocumentTransformationRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateDocumentTransformationRequest
     */
    'scaleX'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDocumentTransformationRequest
     */
    'scaleY'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDocumentTransformationRequest
     */
    'offsetX'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDocumentTransformationRequest
     */
    'offsetY'?: number;
}
/**
 * The customer\'s personal data.
 * @export
 * @interface UpdatePersonaldataRequest
 */
export interface UpdatePersonaldataRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'plz'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaldataRequest
     */
    'partnerId'?: string;
}
/**
 * The customer\'s personal data.
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'debitornumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'plz'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'partnerId'?: string;
}

    /**
    * AccountsApi - axios parameter creator
    * @export
    */
    export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Gets the account\'s financial data. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAccount: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all transctions of a month. 
            * @param {number} month 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAllTransactionsForMonth: async (month: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'month' is not null or undefined
                    assertParamExists('getAllTransactionsForMonth', 'month', month)
            const localVarPath = `/accounts/journal/{month}`
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all transctions of a month for a coworker. 
            * @param {string} debitornumber 
            * @param {number} month 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getCoworkerTransactionsForMonth: async (debitornumber: string, month: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'debitornumber' is not null or undefined
                    assertParamExists('getCoworkerTransactionsForMonth', 'debitornumber', debitornumber)
                    // verify required parameter 'month' is not null or undefined
                    assertParamExists('getCoworkerTransactionsForMonth', 'month', month)
            const localVarPath = `/accounts/coworkers/{debitornumber}/journal/{month}`
                .replace(`{${"debitornumber"}}`, encodeURIComponent(String(debitornumber)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the coworkers. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getCoworkers: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/coworkers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets default options which are assigned to the account. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getOptions: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the account\'s personal data. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getPersonalData: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/personaldata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates default options which are assigned to the account. 
            * @param {Options} defaultOptions 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updateOptions: async (defaultOptions: Options, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'defaultOptions' is not null or undefined
                    assertParamExists('updateOptions', 'defaultOptions', defaultOptions)
            const localVarPath = `/accounts/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(defaultOptions, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates the personal data 
            * @param {UpdatePersonaldataRequest} personalData 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updatePersonaldata: async (personalData: UpdatePersonaldataRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'personalData' is not null or undefined
                    assertParamExists('updatePersonaldata', 'personalData', personalData)
            const localVarPath = `/accounts/personaldata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(personalData, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * AccountsApi - functional programming interface
        * @export
        */
        export const AccountsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
        return {
            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAccount(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all transctions of a month. 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAllTransactionsForMonth(month: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactionsForMonth(month, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all transctions of a month for a coworker. 
                * @param {string} debitornumber 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getCoworkerTransactionsForMonth(debitornumber: string, month: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoworkerTransactionsForMonth(debitornumber, month, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getCoworkers(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coworker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoworkers(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getOptions(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptions(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getPersonalData(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonalData(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates default options which are assigned to the account. 
                * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updateOptions(defaultOptions: Options, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOptions(defaultOptions, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates the personal data 
                * @param {UpdatePersonaldataRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updatePersonaldata(personalData: UpdatePersonaldataRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonaldata(personalData, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * AccountsApi - factory interface
        * @export
        */
        export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = AccountsApiFp(configuration)
        return {
            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAccount(axiosConfig?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all transctions of a month. 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAllTransactionsForMonth(month: number, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.getAllTransactionsForMonth(month, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all transctions of a month for a coworker. 
                * @param {string} debitornumber 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getCoworkerTransactionsForMonth(debitornumber: string, month: number, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.getCoworkerTransactionsForMonth(debitornumber, month, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getCoworkers(axiosConfig?: any): AxiosPromise<Array<Coworker>> {
            return localVarFp.getCoworkers(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getOptions(axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.getOptions(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getPersonalData(axiosConfig?: any): AxiosPromise<User> {
            return localVarFp.getPersonalData(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates default options which are assigned to the account. 
                * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updateOptions(defaultOptions: Options, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.updateOptions(defaultOptions, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates the personal data 
                * @param {UpdatePersonaldataRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updatePersonaldata(personalData: UpdatePersonaldataRequest, axiosConfig?: any): AxiosPromise<User> {
            return localVarFp.updatePersonaldata(personalData, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * AccountsApi - object-oriented interface
        * @export
        * @class AccountsApi
        * @extends {BaseAPI}
        */
            export class AccountsApi extends BaseAPI {
            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getAccount(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getAccount(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all transctions of a month. 
                    * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getAllTransactionsForMonth(month: number, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getAllTransactionsForMonth(month, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all transctions of a month for a coworker. 
                    * @param {string} debitornumber 
                    * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getCoworkerTransactionsForMonth(debitornumber: string, month: number, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getCoworkerTransactionsForMonth(debitornumber, month, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getCoworkers(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getCoworkers(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getOptions(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getOptions(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public getPersonalData(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).getPersonalData(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates default options which are assigned to the account. 
                    * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public updateOptions(defaultOptions: Options, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).updateOptions(defaultOptions, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates the personal data 
                    * @param {UpdatePersonaldataRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public updatePersonaldata(personalData: UpdatePersonaldataRequest, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).updatePersonaldata(personalData, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * AttachmentsApi - axios parameter creator
    * @export
    */
    export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
            * @param {number} attachmentID 
            * @param {Array<number>} [doumentIDs] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        appendAttachmentsToDocuments: async (attachmentID: number, doumentIDs?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('appendAttachmentsToDocuments', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(doumentIDs, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Upload an attachment 
            * @param {CreateDocumentAttachmentRequest} [attachmentData] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createAttachment: async (attachmentData?: CreateDocumentAttachmentRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attachmentData, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteAttachment: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('deleteAttachment', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all attachment references. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAllAttachments: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets referenced attachment. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAttachment: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('getAttachment', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all unsended documents to which this attachment is append. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAttachmentDocuments: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('getAttachmentDocuments', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced attachment as PDF preview. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAttachmentPdf: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('getAttachmentPdf', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/pdf`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced attachment as PNG preview of the first page. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAttachmentPng: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('getAttachmentPng', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/png`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Remove the referenced attachment from all documents, which are not yet shipped. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        removeAttachmentFromDocuments: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('removeAttachmentFromDocuments', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * AttachmentsApi - functional programming interface
        * @export
        */
        export const AttachmentsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
        return {
            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                * @param {number} attachmentID 
                * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async appendAttachmentsToDocuments(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendAttachmentsToDocuments(attachmentID, doumentIDs, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Upload an attachment 
                * @param {CreateDocumentAttachmentRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createAttachment(attachmentData?: CreateDocumentAttachmentRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(attachmentData, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteAttachment(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAllAttachments(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttachments(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets referenced attachment. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAttachment(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all unsended documents to which this attachment is append. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAttachmentDocuments(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentDocuments(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced attachment as PDF preview. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAttachmentPdf(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentPdf(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAttachmentPng(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentPng(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async removeAttachmentFromDocuments(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAttachmentFromDocuments(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * AttachmentsApi - factory interface
        * @export
        */
        export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = AttachmentsApiFp(configuration)
        return {
            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                * @param {number} attachmentID 
                * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        appendAttachmentsToDocuments(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.appendAttachmentsToDocuments(attachmentID, doumentIDs, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Upload an attachment 
                * @param {CreateDocumentAttachmentRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createAttachment(attachmentData?: CreateDocumentAttachmentRequest, axiosConfig?: any): AxiosPromise<Attachment> {
            return localVarFp.createAttachment(attachmentData, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteAttachment(attachmentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAllAttachments(axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.getAllAttachments(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets referenced attachment. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAttachment(attachmentID: number, axiosConfig?: any): AxiosPromise<Attachment> {
            return localVarFp.getAttachment(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all unsended documents to which this attachment is append. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAttachmentDocuments(attachmentID: number, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.getAttachmentDocuments(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced attachment as PDF preview. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAttachmentPdf(attachmentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.getAttachmentPdf(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAttachmentPng(attachmentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.getAttachmentPng(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        removeAttachmentFromDocuments(attachmentID: number, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.removeAttachmentFromDocuments(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * AttachmentsApi - object-oriented interface
        * @export
        * @class AttachmentsApi
        * @extends {BaseAPI}
        */
            export class AttachmentsApi extends BaseAPI {
            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                    * @param {number} attachmentID 
                    * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public appendAttachmentsToDocuments(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).appendAttachmentsToDocuments(attachmentID, doumentIDs, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Upload an attachment 
                    * @param {CreateDocumentAttachmentRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public createAttachment(attachmentData?: CreateDocumentAttachmentRequest, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).createAttachment(attachmentData, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public deleteAttachment(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).deleteAttachment(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public getAllAttachments(axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).getAllAttachments(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets referenced attachment. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public getAttachment(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).getAttachment(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all unsended documents to which this attachment is append. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public getAttachmentDocuments(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).getAttachmentDocuments(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced attachment as PDF preview. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public getAttachmentPdf(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).getAttachmentPdf(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public getAttachmentPng(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).getAttachmentPng(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public removeAttachmentFromDocuments(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).removeAttachmentFromDocuments(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * DocumentsApi - axios parameter creator
    * @export
    */
    export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
            * @param {number} documentID 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        appendDocumentAttachment: async (documentID: number, attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('appendDocumentAttachment', 'documentID', documentID)
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('appendDocumentAttachment', 'attachmentID', attachmentID)
            const localVarPath = `/documents/{documentID}/attachments/{attachmentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
            * @param {CreateDocumentRequest} [upload] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createDocument: async (upload?: CreateDocumentRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(upload, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
            * @param {number} documentID 
            * @param {CreateDocumentAttachmentRequest} [appendAttachment] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createDocumentAttachment: async (documentID: number, appendAttachment?: CreateDocumentAttachmentRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('createDocumentAttachment', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(appendAttachment, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Marks the document with certain attributes. 
            * @param {number} documentID 
            * @param {Array<LetterAttribute>} [attributes] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createDocumentAttributes: async (documentID: number, attributes?: Array<LetterAttribute>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('createDocumentAttributes', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attributes`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attributes, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Deletes the referenced document. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteDocument', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Detach all attachments of the document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteDocumentAttachments: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteDocumentAttachments', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes an attribute from the document. 
            * @param {number} documentID 
            * @param {string} key 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteDocumentAttribute: async (documentID: number, key: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteDocumentAttribute', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('deleteDocumentAttribute', 'key', key)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes the cover page from the document. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteDocumentCoverpage: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteDocumentCoverpage', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/coverpage`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes the performed transformation on the document and rolls back to the original version of the document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteDocumentTransformation: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteDocumentTransformation', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/transformations`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
            * @param {Array<string>} key 
            * @param {Array<string>} value 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        findDocumentByAttributes: async (key: Array<string>, value: Array<string>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('findDocumentByAttributes', 'key', key)
                    // verify required parameter 'value' is not null or undefined
                    assertParamExists('findDocumentByAttributes', 'value', value)
            const localVarPath = `/documents/findbyAttributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)

                    if (key) {
                            localVarQueryParameter['key'] = key;
                    }

                    if (value) {
                            localVarQueryParameter['value'] = value;
                    }


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAllDocuments: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAllErrors: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocument', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s all attachments 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentAttachments: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentAttachments', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the document\'s attribute for a specified key. 
            * @param {number} documentID 
            * @param {string} key 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentAttribute: async (documentID: number, key: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentAttribute', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('getDocumentAttribute', 'key', key)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s attributes 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentAttributes: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentAttributes', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attributes`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s options. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentOptions: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentOptions', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/options`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document as PDF preview. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentPdf: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentPdf', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/pdf`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document as PNG preview. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentPng: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentPng', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/png`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of a document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getDocumentStatus: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getDocumentStatus', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/status`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
            * @param {number} documentID 
            * @param {Array<number>} [attachmentIDs] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        patchDocumentAttachments: async (documentID: number, attachmentIDs?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('patchDocumentAttachments', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attachmentIDs, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Remove an attachment from the document 
            * @param {number} documentID 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        removeDocumentAttachment: async (documentID: number, attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('removeDocumentAttachment', 'documentID', documentID)
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('removeDocumentAttachment', 'attachmentID', attachmentID)
            const localVarPath = `/documents/{documentID}/attachments/{attachmentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates the document\'s attribute for a specified key. 
            * @param {number} documentID 
            * @param {string} key 
            * @param {string} value 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updateDocumentAttribute: async (documentID: number, key: string, value: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('updateDocumentAttribute', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('updateDocumentAttribute', 'key', key)
                    // verify required parameter 'value' is not null or undefined
                    assertParamExists('updateDocumentAttribute', 'value', value)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
                const localVarFormParams = new URLSearchParams();

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


                        if (value !== undefined) { 
                            localVarFormParams.set('value', value as any);
                        }
            
        
                localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = localVarFormParams.toString();

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
            * @param {number} documentID 
            * @param {UpdateDocumentCoverpageRequest} [coverPage] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updateDocumentCoverpage: async (documentID: number, coverPage?: UpdateDocumentCoverpageRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('updateDocumentCoverpage', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/coverpage`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(coverPage, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates document\'s options 
            * @param {number} documentID 
            * @param {Options} [options] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updateDocumentOptions: async (documentID: number, options?: Options, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('updateDocumentOptions', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/options`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(options, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
            * @param {number} documentID 
            * @param {UpdateDocumentTransformationRequest} transformation 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        updateDocumentTransformation: async (documentID: number, transformation: UpdateDocumentTransformationRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('updateDocumentTransformation', 'documentID', documentID)
                    // verify required parameter 'transformation' is not null or undefined
                    assertParamExists('updateDocumentTransformation', 'transformation', transformation)
            const localVarPath = `/documents/{documentID}/transformations`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(transformation, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * DocumentsApi - functional programming interface
        * @export
        */
        export const DocumentsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
        return {
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async appendDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendDocumentAttachment(documentID, attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                * @param {CreateDocumentRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createDocument(upload?: CreateDocumentRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocument(upload, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {CreateDocumentAttachmentRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createDocumentAttachment(documentID: number, appendAttachment?: CreateDocumentAttachmentRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentAttachment(documentID, appendAttachment, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Marks the document with certain attributes. 
                * @param {number} documentID 
                * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createDocumentAttributes(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LetterAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentAttributes(documentID, attributes, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Deletes the referenced document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Detach all attachments of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteDocumentAttachments(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentAttachments(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes an attribute from the document. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteDocumentAttribute(documentID: number, key: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentAttribute(documentID, key, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes the cover page from the document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteDocumentCoverpage(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentCoverpage(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteDocumentTransformation(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentTransformation(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                * @param {Array<string>} key 
                * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async findDocumentByAttributes(key: Array<string>, value: Array<string>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDocumentByAttributes(key, value, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAllDocuments(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDocuments(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAllErrors(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllErrors(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s all attachments 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentAttachments(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentAttachments(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentAttribute(documentID: number, key: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentAttribute(documentID, key, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s attributes 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentAttributes(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LetterAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentAttributes(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s options. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentOptions(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentOptions(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document as PDF preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentPdf(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentPdf(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document as PNG preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentPng(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentPng(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of a document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getDocumentStatus(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentStatus(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                * @param {number} documentID 
                * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async patchDocumentAttachments(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchDocumentAttachments(documentID, attachmentIDs, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Remove an attachment from the document 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async removeDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDocumentAttachment(documentID, attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
                * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updateDocumentAttribute(documentID: number, key: string, value: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentAttribute(documentID, key, value, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                * @param {number} documentID 
                * @param {UpdateDocumentCoverpageRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updateDocumentCoverpage(documentID: number, coverPage?: UpdateDocumentCoverpageRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentCoverpage(documentID, coverPage, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates document\'s options 
                * @param {number} documentID 
                * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updateDocumentOptions(documentID: number, options?: Options, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentOptions(documentID, options, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                * @param {number} documentID 
                * @param {UpdateDocumentTransformationRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async updateDocumentTransformation(documentID: number, transformation: UpdateDocumentTransformationRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentTransformation(documentID, transformation, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * DocumentsApi - factory interface
        * @export
        */
        export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = DocumentsApiFp(configuration)
        return {
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        appendDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.appendDocumentAttachment(documentID, attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                * @param {CreateDocumentRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createDocument(upload?: CreateDocumentRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.createDocument(upload, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {CreateDocumentAttachmentRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createDocumentAttachment(documentID: number, appendAttachment?: CreateDocumentAttachmentRequest, axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.createDocumentAttachment(documentID, appendAttachment, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Marks the document with certain attributes. 
                * @param {number} documentID 
                * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createDocumentAttributes(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: any): AxiosPromise<Array<LetterAttribute>> {
            return localVarFp.createDocumentAttributes(documentID, attributes, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Deletes the referenced document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteDocument(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Detach all attachments of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteDocumentAttachments(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.deleteDocumentAttachments(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes an attribute from the document. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteDocumentAttribute(documentID: number, key: string, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentAttribute(documentID, key, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes the cover page from the document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteDocumentCoverpage(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentCoverpage(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteDocumentTransformation(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteDocumentTransformation(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                * @param {Array<string>} key 
                * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        findDocumentByAttributes(key: Array<string>, value: Array<string>, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.findDocumentByAttributes(key, value, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAllDocuments(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.getAllDocuments(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAllErrors(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.getAllErrors(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocument(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.getDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s all attachments 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentAttachments(documentID: number, axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.getDocumentAttachments(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentAttribute(documentID: number, key: string, axiosConfig?: any): AxiosPromise<LetterAttribute> {
            return localVarFp.getDocumentAttribute(documentID, key, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s attributes 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentAttributes(documentID: number, axiosConfig?: any): AxiosPromise<Array<LetterAttribute>> {
            return localVarFp.getDocumentAttributes(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s options. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentOptions(documentID: number, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.getDocumentOptions(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document as PDF preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentPdf(documentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.getDocumentPdf(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document as PNG preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentPng(documentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.getDocumentPng(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of a document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getDocumentStatus(documentID: number, axiosConfig?: any): AxiosPromise<DocumentStatus> {
            return localVarFp.getDocumentStatus(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                * @param {number} documentID 
                * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        patchDocumentAttachments(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.patchDocumentAttachments(documentID, attachmentIDs, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Remove an attachment from the document 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        removeDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.removeDocumentAttachment(documentID, attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
                * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updateDocumentAttribute(documentID: number, key: string, value: string, axiosConfig?: any): AxiosPromise<LetterAttribute> {
            return localVarFp.updateDocumentAttribute(documentID, key, value, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                * @param {number} documentID 
                * @param {UpdateDocumentCoverpageRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updateDocumentCoverpage(documentID: number, coverPage?: UpdateDocumentCoverpageRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.updateDocumentCoverpage(documentID, coverPage, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates document\'s options 
                * @param {number} documentID 
                * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updateDocumentOptions(documentID: number, options?: Options, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.updateDocumentOptions(documentID, options, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                * @param {number} documentID 
                * @param {UpdateDocumentTransformationRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        updateDocumentTransformation(documentID: number, transformation: UpdateDocumentTransformationRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.updateDocumentTransformation(documentID, transformation, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * DocumentsApi - object-oriented interface
        * @export
        * @class DocumentsApi
        * @extends {BaseAPI}
        */
            export class DocumentsApi extends BaseAPI {
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                    * @param {number} documentID 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public appendDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).appendDocumentAttachment(documentID, attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                    * @param {CreateDocumentRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public createDocument(upload?: CreateDocumentRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).createDocument(upload, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                    * @param {number} documentID 
                    * @param {CreateDocumentAttachmentRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public createDocumentAttachment(documentID: number, appendAttachment?: CreateDocumentAttachmentRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).createDocumentAttachment(documentID, appendAttachment, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Marks the document with certain attributes. 
                    * @param {number} documentID 
                    * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public createDocumentAttributes(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).createDocumentAttributes(documentID, attributes, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Deletes the referenced document. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public deleteDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).deleteDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Detach all attachments of the document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public deleteDocumentAttachments(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).deleteDocumentAttachments(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes an attribute from the document. 
                    * @param {number} documentID 
                    * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public deleteDocumentAttribute(documentID: number, key: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).deleteDocumentAttribute(documentID, key, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes the cover page from the document. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public deleteDocumentCoverpage(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).deleteDocumentCoverpage(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public deleteDocumentTransformation(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).deleteDocumentTransformation(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                    * @param {Array<string>} key 
                    * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public findDocumentByAttributes(key: Array<string>, value: Array<string>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).findDocumentByAttributes(key, value, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getAllDocuments(axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getAllDocuments(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getAllErrors(axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getAllErrors(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s all attachments 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentAttachments(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentAttachments(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the document\'s attribute for a specified key. 
                    * @param {number} documentID 
                    * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentAttribute(documentID: number, key: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentAttribute(documentID, key, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s attributes 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentAttributes(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentAttributes(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s options. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentOptions(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentOptions(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document as PDF preview. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentPdf(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentPdf(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document as PNG preview. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentPng(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentPng(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of a document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public getDocumentStatus(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).getDocumentStatus(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                    * @param {number} documentID 
                    * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public patchDocumentAttachments(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).patchDocumentAttachments(documentID, attachmentIDs, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Remove an attachment from the document 
                    * @param {number} documentID 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public removeDocumentAttachment(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).removeDocumentAttachment(documentID, attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates the document\'s attribute for a specified key. 
                    * @param {number} documentID 
                    * @param {string} key 
                    * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public updateDocumentAttribute(documentID: number, key: string, value: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).updateDocumentAttribute(documentID, key, value, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                    * @param {number} documentID 
                    * @param {UpdateDocumentCoverpageRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public updateDocumentCoverpage(documentID: number, coverPage?: UpdateDocumentCoverpageRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).updateDocumentCoverpage(documentID, coverPage, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates document\'s options 
                    * @param {number} documentID 
                    * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public updateDocumentOptions(documentID: number, options?: Options, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).updateDocumentOptions(documentID, options, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                    * @param {number} documentID 
                    * @param {UpdateDocumentTransformationRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public updateDocumentTransformation(documentID: number, transformation: UpdateDocumentTransformationRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).updateDocumentTransformation(documentID, transformation, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * InvoicesApi - axios parameter creator
    * @export
    */
    export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Gets all transctions of the invoice. 
            * @param {string} invoiceNumber 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getInvoice: async (invoiceNumber: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'invoiceNumber' is not null or undefined
                    assertParamExists('getInvoice', 'invoiceNumber', invoiceNumber)
            const localVarPath = `/invoices/{invoiceNumber}`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Get a specific invoice as PDF. 
            * @param {string} invoiceNumber 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getInvoicePdf: async (invoiceNumber: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'invoiceNumber' is not null or undefined
                    assertParamExists('getInvoicePdf', 'invoiceNumber', invoiceNumber)
            const localVarPath = `/invoices/{invoiceNumber}/pdf`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all stored invoices references. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getInvoices: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * InvoicesApi - functional programming interface
        * @export
        */
        export const InvoicesApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
        return {
            /**
            * Gets all transctions of the invoice. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getInvoice(invoiceNumber: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(invoiceNumber, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Get a specific invoice as PDF. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getInvoicePdf(invoiceNumber: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePdf(invoiceNumber, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getInvoices(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * InvoicesApi - factory interface
        * @export
        */
        export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = InvoicesApiFp(configuration)
        return {
            /**
            * Gets all transctions of the invoice. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getInvoice(invoiceNumber: string, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.getInvoice(invoiceNumber, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Get a specific invoice as PDF. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getInvoicePdf(invoiceNumber: string, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.getInvoicePdf(invoiceNumber, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getInvoices(axiosConfig?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getInvoices(axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * InvoicesApi - object-oriented interface
        * @export
        * @class InvoicesApi
        * @extends {BaseAPI}
        */
            export class InvoicesApi extends BaseAPI {
            /**
            * Gets all transctions of the invoice. 
                    * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public getInvoice(invoiceNumber: string, axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).getInvoice(invoiceNumber, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Get a specific invoice as PDF. 
                    * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public getInvoicePdf(invoiceNumber: string, axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).getInvoicePdf(invoiceNumber, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public getInvoices(axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).getInvoices(axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * SendingsApi - axios parameter creator
    * @export
    */
    export const SendingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Cancels the delivery of a letter, if it isn\'t already shipped. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        cancelSendingForDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('cancelSendingForDocument', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        cancelSendings: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(documentIds, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Announces the delivery of a letter, if it isn\'t yet shipped. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createSendingForDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('createSendingForDocument', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        createSendings: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(documentIds, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Deletes a canceled or a delivered and sent document from the system. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        deleteSendingForDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('deleteSendingForDocument', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getAllSendings: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getSendingDocumentStatus: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getSendingDocumentStatus', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}/status`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getSendingForDocument: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('getSendingForDocument', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        getSendingStatus: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)

                    if (documentIds) {
                            localVarQueryParameter['documentIds'] = documentIds;
                    }


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Document is directly sent after upload, if it is successfully validated. 
            * @param {SendDocumentRequest} [shipping] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendDocument: async (shipping?: SendDocumentRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(shipping, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * SendingsApi - functional programming interface
        * @export
        */
        export const SendingsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = SendingsApiAxiosParamCreator(configuration)
        return {
            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async cancelSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSendingForDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async cancelSendings(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSendings(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSendingForDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async createSendings(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSendings(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async deleteSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSendingForDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getAllSendings(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSendings(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getSendingDocumentStatus(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSendingDocumentStatus(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSendingForDocument(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async getSendingStatus(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSendingStatus(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Document is directly sent after upload, if it is successfully validated. 
                * @param {SendDocumentRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendDocument(shipping?: SendDocumentRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDocument(shipping, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * SendingsApi - factory interface
        * @export
        */
        export const SendingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = SendingsApiFp(configuration)
        return {
            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        cancelSendingForDocument(documentID: number, axiosConfig?: any): AxiosPromise<Status> {
            return localVarFp.cancelSendingForDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        cancelSendings(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.cancelSendings(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createSendingForDocument(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.createSendingForDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        createSendings(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.createSendings(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        deleteSendingForDocument(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.deleteSendingForDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getAllSendings(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.getAllSendings(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getSendingDocumentStatus(documentID: number, axiosConfig?: any): AxiosPromise<DocumentStatus> {
            return localVarFp.getSendingDocumentStatus(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getSendingForDocument(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.getSendingForDocument(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        getSendingStatus(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.getSendingStatus(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Document is directly sent after upload, if it is successfully validated. 
                * @param {SendDocumentRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendDocument(shipping?: SendDocumentRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.sendDocument(shipping, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * SendingsApi - object-oriented interface
        * @export
        * @class SendingsApi
        * @extends {BaseAPI}
        */
            export class SendingsApi extends BaseAPI {
            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public cancelSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).cancelSendingForDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public cancelSendings(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).cancelSendings(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public createSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).createSendingForDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public createSendings(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).createSendings(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public deleteSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).deleteSendingForDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public getAllSendings(axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).getAllSendings(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public getSendingDocumentStatus(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).getSendingDocumentStatus(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public getSendingForDocument(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).getSendingForDocument(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public getSendingStatus(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).getSendingStatus(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Document is directly sent after upload, if it is successfully validated. 
                    * @param {SendDocumentRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendDocument(shipping?: SendDocumentRequest, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendDocument(shipping, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


