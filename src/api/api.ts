/* tslint:disable */
/* eslint-disable */
/**
 * Binect API REST
 * Webservice für den Briefversand. Ihre Briefe werden durch unser System ausgedruckt, kuvertiert, frankiert und zur Deutschen Post gebracht.  Für eine detaillierte Beschreibung schauen Sie bitte in das Modell. </br></br>Hinweis: Wenn Sie als Benutzer eingeloggt sind, laufen alle Anfragen gegen das Produktiv-System. </br>Somit stornieren, l&ouml;schen, ... oder versenden Sie Ihre Briefe wirklich!</br> Falls Sie Zugriff auf unser Testsystem ben&ouml;tigen, stellen Sie gerne eine Anfrage an kontakt@binect.de.
 *
 * The version of the OpenAPI document: 0.9.5-beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * account data
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'credit': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'promotionCredit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'creditLimit'?: number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Account
     */
    'unit': CurrencyEnum;
}
/**
 * The customer\'s personal data.
 * @export
 * @interface AccountsPersonaldataGetRequest
 */
export interface AccountsPersonaldataGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'plz'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsPersonaldataGetRequest
     */
    'partnerId'?: string;
}
/**
 * Describe an action of a transaction
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * Following action codes are defined:   1 (is sent),    2 (is canceled),    3 (delivery error)  
     * @type {number}
     * @memberof Action
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'text': string;
}
/**
 * Adress.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'nameExtend'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'numberOfPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof Attachment
     */
    'newSheet': boolean;
    /**
     * This attachment appended to \'n\' documents
     * @type {number}
     * @memberof Attachment
     */
    'ntimesUsed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'remarks'?: string;
}
/**
 * The content of the file and file name. The content must be base64 encoded.
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * 
     * @type {string}
     * @memberof Content
     */
    'filename': string;
    /**
     * 
     * @type {any}
     * @memberof Content
     */
    'content': any;
}
/**
 * The coworkers data.
 * @export
 * @interface Coworker
 */
export interface Coworker {
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'debitornumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coworker
     */
    'registrationDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Coworker
     */
    'numberOfSendings'?: number;
    /**
     * 
     * @type {Price}
     * @memberof Coworker
     */
    'totalAmount'?: Price;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyEnum = {
    Eurocent: 'eurocent'
} as const;

export type CurrencyEnum = typeof CurrencyEnum[keyof typeof CurrencyEnum];


/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'filename': string;
    /**
     * 
     * @type {number}
     * @memberof Document
     */
    'numberOfPages'?: number;
    /**
     * 
     * @type {Status}
     * @memberof Document
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'documentType': DocumentDocumentTypeEnum;
    /**
     * 
     * @type {Letter}
     * @memberof Document
     */
    'letter'?: Letter;
    /**
     * 
     * @type {SerialLetter}
     * @memberof Document
     */
    'serialLetter'?: SerialLetter;
}

export const DocumentDocumentTypeEnum = {
    Letter: 'Letter',
    SerialLetter: 'SerialLetter'
} as const;

export type DocumentDocumentTypeEnum = typeof DocumentDocumentTypeEnum[keyof typeof DocumentDocumentTypeEnum];

/**
 * 
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * 
     * @type {number}
     * @memberof DocumentStatus
     */
    'id': number;
    /**
     * 
     * @type {Status}
     * @memberof DocumentStatus
     */
    'status': Status;
}
/**
 * 
 * @export
 * @interface DocumentsDocumentIDAttachmentsDeleteRequest
 */
export interface DocumentsDocumentIDAttachmentsDeleteRequest {
    /**
     * 
     * @type {Content}
     * @memberof DocumentsDocumentIDAttachmentsDeleteRequest
     */
    'content': Content;
    /**
     * The Attachment will start on the front page of a sheet
     * @type {boolean}
     * @memberof DocumentsDocumentIDAttachmentsDeleteRequest
     */
    'newSheet'?: boolean;
    /**
     * Remarks to the attachment
     * @type {string}
     * @memberof DocumentsDocumentIDAttachmentsDeleteRequest
     */
    'remarks'?: string;
}
/**
 * 
 * @export
 * @interface DocumentsDocumentIDCoverpageDeleteRequest
 */
export interface DocumentsDocumentIDCoverpageDeleteRequest {
    /**
     * 
     * @type {Address}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequest
     */
    'receivingAddress': Address;
    /**
     * 
     * @type {Address}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequest
     */
    'returnAddress'?: Address;
    /**
     * 
     * @type {DocumentsDocumentIDCoverpageDeleteRequestCoverText}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequest
     */
    'coverText'?: DocumentsDocumentIDCoverpageDeleteRequestCoverText;
}
/**
 * optional text on the cover page
 * @export
 * @interface DocumentsDocumentIDCoverpageDeleteRequestCoverText
 */
export interface DocumentsDocumentIDCoverpageDeleteRequestCoverText {
    /**
     * optional subject text on the cover page
     * @type {string}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequestCoverText
     */
    'subject'?: string;
    /**
     * optional date on the cover page
     * @type {string}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequestCoverText
     */
    'date'?: string;
    /**
     * Text on the cover page. Only plain text is supported. Start a new line with \'\\n\'.
     * @type {string}
     * @memberof DocumentsDocumentIDCoverpageDeleteRequestCoverText
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface DocumentsDocumentIDTransformationsDeleteRequest
 */
export interface DocumentsDocumentIDTransformationsDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof DocumentsDocumentIDTransformationsDeleteRequest
     */
    'scaleX'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentsDocumentIDTransformationsDeleteRequest
     */
    'scaleY'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentsDocumentIDTransformationsDeleteRequest
     */
    'offsetX'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentsDocumentIDTransformationsDeleteRequest
     */
    'offsetY'?: number;
}
/**
 * 
 * @export
 * @interface DocumentsGetRequest
 */
export interface DocumentsGetRequest {
    /**
     * 
     * @type {Content}
     * @memberof DocumentsGetRequest
     */
    'content': Content;
    /**
     * 
     * @type {Options}
     * @memberof DocumentsGetRequest
     */
    'options'?: Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof DocumentsGetRequest
     */
    'attributes'?: Array<LetterAttribute>;
    /**
     * 
     * @type {DocumentsGetRequestSplitParams}
     * @memberof DocumentsGetRequest
     */
    'splitParams'?: DocumentsGetRequestSplitParams;
}
/**
 * If the uploaded document is a serial letter, define how it shall be split.
 * @export
 * @interface DocumentsGetRequestSplitParams
 */
export interface DocumentsGetRequestSplitParams {
    /**
     * This token is used to split the serial letter.
     * @type {string}
     * @memberof DocumentsGetRequestSplitParams
     */
    'splitToken'?: string;
    /**
     * Every N pages the serial letter is split.
     * @type {number}
     * @memberof DocumentsGetRequestSplitParams
     */
    'splitAfterNumberOfPages'?: number;
}
/**
 * 
 * @export
 * @interface ErrorParam
 */
export interface ErrorParam {
    /**
     * 
     * @type {string}
     * @memberof ErrorParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorParam
     */
    'value': string;
}
/**
 * Invoice.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'filename': string;
    /**
     * 
     * @type {Price}
     * @memberof Invoice
     */
    'totalAmount'?: Price;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface Letter
 */
export interface Letter {
    /**
     * 
     * @type {string}
     * @memberof Letter
     */
    'letterType': LetterLetterTypeEnum;
    /**
     * 
     * @type {LetterData}
     * @memberof Letter
     */
    'letterData'?: LetterData;
    /**
     * 
     * @type {Array<Error>}
     * @memberof Letter
     */
    'errors'?: Array<Error>;
}

export const LetterLetterTypeEnum = {
    LetterData: 'LetterData',
    Error: 'Error'
} as const;

export type LetterLetterTypeEnum = typeof LetterLetterTypeEnum[keyof typeof LetterLetterTypeEnum];

/**
 * 
 * @export
 * @interface LetterAttribute
 */
export interface LetterAttribute {
    /**
     * 
     * @type {string}
     * @memberof LetterAttribute
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof LetterAttribute
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface LetterData
 */
export interface LetterData {
    /**
     * 
     * @type {string}
     * @memberof LetterData
     */
    'recipientAddress': string;
    /**
     * 
     * @type {Price}
     * @memberof LetterData
     */
    'price': Price;
    /**
     * 
     * @type {boolean}
     * @memberof LetterData
     */
    'international': boolean;
    /**
     * 
     * @type {Options}
     * @memberof LetterData
     */
    'options': Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof LetterData
     */
    'attributes'?: Array<LetterAttribute>;
    /**
     * The Attachments which are appended to this document. </br>Only documents from documentType \'Letter\' can have attachments
     * @type {Array<Attachment>}
     * @memberof LetterData
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Binect error code.
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * Human readable error text with filled-in place holders.
     * @type {string}
     * @memberof ModelError
     */
    'text': string;
    /**
     * Text with place holders for parameters.  Place holders are framed in %-Symbols, e. g. \'error on page number %pageNr% of your document\'.
     * @type {string}
     * @memberof ModelError
     */
    'blankText': string;
    /**
     * Parameters for place holder in \'blankText\'.
     * @type {Array<ErrorParam>}
     * @memberof ModelError
     */
    'parameters'?: Array<ErrorParam>;
    /**
     * On which page of the document the error occurred.
     * @type {number}
     * @memberof ModelError
     */
    'errorOnPage'?: number;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * if false it is duplex
     * @type {boolean}
     * @memberof Options
     */
    'simplex': boolean;
    /**
     * if false it is black and white
     * @type {boolean}
     * @memberof Options
     */
    'color': boolean;
    /**
     * Shall only be used for \'C4\', otherwise not used. \'C4\' is the only supported value.
     * @type {string}
     * @memberof Options
     */
    'envelope'?: OptionsEnvelopeEnum;
}

export const OptionsEnvelopeEnum = {
    C4: 'C4'
} as const;

export type OptionsEnvelopeEnum = typeof OptionsEnvelopeEnum[keyof typeof OptionsEnvelopeEnum];

/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'priceBeforeTax': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'priceAfterTax': number;
    /**
     * 
     * @type {CurrencyEnum}
     * @memberof Price
     */
    'unit': CurrencyEnum;
    /**
     * e. g. 19 for 19% sales tax
     * @type {number}
     * @memberof Price
     */
    'taxInPercent': number;
}
/**
 * 
 * @export
 * @interface SendingsDocumentPostRequest
 */
export interface SendingsDocumentPostRequest {
    /**
     * 
     * @type {Content}
     * @memberof SendingsDocumentPostRequest
     */
    'content': Content;
    /**
     * 
     * @type {Options}
     * @memberof SendingsDocumentPostRequest
     */
    'options'?: Options;
    /**
     * 
     * @type {Array<LetterAttribute>}
     * @memberof SendingsDocumentPostRequest
     */
    'attributes'?: Array<LetterAttribute>;
}
/**
 * 
 * @export
 * @interface SerialLetter
 */
export interface SerialLetter {
    /**
     * This token is used to split the serial letter.
     * @type {string}
     * @memberof SerialLetter
     */
    'splitToken'?: string;
    /**
     * Every N pages, the serial letter is split.
     * @type {number}
     * @memberof SerialLetter
     */
    'splitAfterNumberOfPages'?: number;
    /**
     * 
     * @type {SerialLetterStatus}
     * @memberof SerialLetter
     */
    'status'?: SerialLetterStatus;
    /**
     * 
     * @type {Array<Document>}
     * @memberof SerialLetter
     */
    'letters'?: Array<Document>;
}
/**
 * 
 * @export
 * @interface SerialLetterStatus
 */
export interface SerialLetterStatus {
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrTotal': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrGenerated': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrSuccess': number;
    /**
     * 
     * @type {number}
     * @memberof SerialLetterStatus
     */
    'nrError': number;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Following status codes are defined:   1 (in preparation),    2 (is shippable),    3 (in production, waiting to be sent),    4 (in print process),    5 (is sent),    6 (is canceled),    7 (is erroneous)  
     * @type {number}
     * @memberof Status
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'text': string;
}
/**
 * Invoice.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * 
     * @type {Action}
     * @memberof Transaction
     */
    'action': Action;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'filename'?: string;
    /**
     * 
     * @type {Price}
     * @memberof Transaction
     */
    'amount'?: Price;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'numberOfPages'?: number;
    /**
     * 
     * @type {Options}
     * @memberof Transaction
     */
    'options'?: Options;
    /**
     * 
     * @type {Status}
     * @memberof Transaction
     */
    'status'?: Status;
    /**
     * Debitornumber of coworker
     * @type {string}
     * @memberof Transaction
     */
    'coworker'?: string;
}
/**
 * The customer\'s personal data.
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'debitornumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'plz'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'partnerId'?: string;
}

    /**
    * AccountsApi - axios parameter creator
    * @export
    */
    export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Gets all transctions of a month for a coworker. 
            * @param {string} debitornumber 
            * @param {number} month 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsCoworkersDebitornumberJournalMonthGet: async (debitornumber: string, month: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'debitornumber' is not null or undefined
                    assertParamExists('accountsCoworkersDebitornumberJournalMonthGet', 'debitornumber', debitornumber)
                    // verify required parameter 'month' is not null or undefined
                    assertParamExists('accountsCoworkersDebitornumberJournalMonthGet', 'month', month)
            const localVarPath = `/accounts/coworkers/{debitornumber}/journal/{month}`
                .replace(`{${"debitornumber"}}`, encodeURIComponent(String(debitornumber)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the coworkers. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsCoworkersGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/coworkers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the account\'s financial data. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all transctions of a month. 
            * @param {number} month 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsJournalMonthGet: async (month: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'month' is not null or undefined
                    assertParamExists('accountsJournalMonthGet', 'month', month)
            const localVarPath = `/accounts/journal/{month}`
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets default options which are assigned to the account. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsOptionsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates default options which are assigned to the account. 
            * @param {Options} defaultOptions 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsOptionsPut: async (defaultOptions: Options, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'defaultOptions' is not null or undefined
                    assertParamExists('accountsOptionsPut', 'defaultOptions', defaultOptions)
            const localVarPath = `/accounts/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(defaultOptions, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the account\'s personal data. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsPersonaldataGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/personaldata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates the personal data 
            * @param {AccountsPersonaldataGetRequest} personalData 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        accountsPersonaldataPatch: async (personalData: AccountsPersonaldataGetRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'personalData' is not null or undefined
                    assertParamExists('accountsPersonaldataPatch', 'personalData', personalData)
            const localVarPath = `/accounts/personaldata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(personalData, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * AccountsApi - functional programming interface
        * @export
        */
        export const AccountsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
        return {
            /**
            * Gets all transctions of a month for a coworker. 
                * @param {string} debitornumber 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsCoworkersDebitornumberJournalMonthGet(debitornumber: string, month: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCoworkersDebitornumberJournalMonthGet(debitornumber, month, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsCoworkersGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coworker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsCoworkersGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all transctions of a month. 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsJournalMonthGet(month: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsJournalMonthGet(month, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsOptionsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOptionsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates default options which are assigned to the account. 
                * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsOptionsPut(defaultOptions: Options, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOptionsPut(defaultOptions, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsPersonaldataGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPersonaldataGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates the personal data 
                * @param {AccountsPersonaldataGetRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async accountsPersonaldataPatch(personalData: AccountsPersonaldataGetRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPersonaldataPatch(personalData, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * AccountsApi - factory interface
        * @export
        */
        export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = AccountsApiFp(configuration)
        return {
            /**
            * Gets all transctions of a month for a coworker. 
                * @param {string} debitornumber 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsCoworkersDebitornumberJournalMonthGet(debitornumber: string, month: number, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.accountsCoworkersDebitornumberJournalMonthGet(debitornumber, month, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsCoworkersGet(axiosConfig?: any): AxiosPromise<Array<Coworker>> {
            return localVarFp.accountsCoworkersGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsGet(axiosConfig?: any): AxiosPromise<Account> {
            return localVarFp.accountsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all transctions of a month. 
                * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsJournalMonthGet(month: number, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.accountsJournalMonthGet(month, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsOptionsGet(axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.accountsOptionsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates default options which are assigned to the account. 
                * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsOptionsPut(defaultOptions: Options, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.accountsOptionsPut(defaultOptions, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsPersonaldataGet(axiosConfig?: any): AxiosPromise<User> {
            return localVarFp.accountsPersonaldataGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates the personal data 
                * @param {AccountsPersonaldataGetRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        accountsPersonaldataPatch(personalData: AccountsPersonaldataGetRequest, axiosConfig?: any): AxiosPromise<User> {
            return localVarFp.accountsPersonaldataPatch(personalData, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * AccountsApi - object-oriented interface
        * @export
        * @class AccountsApi
        * @extends {BaseAPI}
        */
            export class AccountsApi extends BaseAPI {
            /**
            * Gets all transctions of a month for a coworker. 
                    * @param {string} debitornumber 
                    * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsCoworkersDebitornumberJournalMonthGet(debitornumber: string, month: number, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsCoworkersDebitornumberJournalMonthGet(debitornumber, month, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the coworkers. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsCoworkersGet(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsCoworkersGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the account\'s financial data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsGet(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all transctions of a month. 
                    * @param {number} month 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsJournalMonthGet(month: number, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsJournalMonthGet(month, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets default options which are assigned to the account. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsOptionsGet(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsOptionsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates default options which are assigned to the account. 
                    * @param {Options} defaultOptions 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsOptionsPut(defaultOptions: Options, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsOptionsPut(defaultOptions, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the account\'s personal data. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsPersonaldataGet(axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsPersonaldataGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates the personal data 
                    * @param {AccountsPersonaldataGetRequest} personalData 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AccountsApi
            */
                public accountsPersonaldataPatch(personalData: AccountsPersonaldataGetRequest, axiosConfig?: AxiosRequestConfig) {
                return AccountsApiFp(this.configuration).accountsPersonaldataPatch(personalData, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * AttachmentsApi - axios parameter creator
    * @export
    */
    export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDDelete: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDDelete', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Remove the referenced attachment from all documents, which are not yet shipped. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDDocumentsDelete: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDDocumentsDelete', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all unsended documents to which this attachment is append. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDDocumentsGet: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDDocumentsGet', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
            * @param {number} attachmentID 
            * @param {Array<number>} [doumentIDs] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDDocumentsPatch: async (attachmentID: number, doumentIDs?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDDocumentsPatch', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/documents`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(doumentIDs, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets referenced attachment. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDGet: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDGet', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced attachment as PDF preview. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDPdfGet: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDPdfGet', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/pdf`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced attachment as PNG preview of the first page. 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsAttachmentIDPngGet: async (attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('attachmentsAttachmentIDPngGet', 'attachmentID', attachmentID)
            const localVarPath = `/attachments/{attachmentID}/png`
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all attachment references. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Upload an attachment 
            * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [attachmentData] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        attachmentsPost: async (attachmentData?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attachmentData, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * AttachmentsApi - functional programming interface
        * @export
        */
        export const AttachmentsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
        return {
            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDDelete(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDDelete(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDDocumentsDelete(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDDocumentsDelete(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all unsended documents to which this attachment is append. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDDocumentsGet(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDDocumentsGet(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                * @param {number} attachmentID 
                * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDDocumentsPatch(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDDocumentsPatch(attachmentID, doumentIDs, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets referenced attachment. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDGet(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDGet(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced attachment as PDF preview. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDPdfGet(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDPdfGet(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsAttachmentIDPngGet(attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsAttachmentIDPngGet(attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Upload an attachment 
                * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async attachmentsPost(attachmentData?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentsPost(attachmentData, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * AttachmentsApi - factory interface
        * @export
        */
        export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = AttachmentsApiFp(configuration)
        return {
            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDDelete(attachmentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.attachmentsAttachmentIDDelete(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDDocumentsDelete(attachmentID: number, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.attachmentsAttachmentIDDocumentsDelete(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all unsended documents to which this attachment is append. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDDocumentsGet(attachmentID: number, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.attachmentsAttachmentIDDocumentsGet(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                * @param {number} attachmentID 
                * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDDocumentsPatch(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.attachmentsAttachmentIDDocumentsPatch(attachmentID, doumentIDs, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets referenced attachment. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDGet(attachmentID: number, axiosConfig?: any): AxiosPromise<Attachment> {
            return localVarFp.attachmentsAttachmentIDGet(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced attachment as PDF preview. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDPdfGet(attachmentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.attachmentsAttachmentIDPdfGet(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsAttachmentIDPngGet(attachmentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.attachmentsAttachmentIDPngGet(attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsGet(axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.attachmentsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Upload an attachment 
                * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        attachmentsPost(attachmentData?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: any): AxiosPromise<Attachment> {
            return localVarFp.attachmentsPost(attachmentData, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * AttachmentsApi - object-oriented interface
        * @export
        * @class AttachmentsApi
        * @extends {BaseAPI}
        */
            export class AttachmentsApi extends BaseAPI {
            /**
            * Delete the referenced attachment.</br>The attachment can only be deleted if it is not appended to a none sended document.
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDDelete(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDDelete(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Remove the referenced attachment from all documents, which are not yet shipped. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDDocumentsDelete(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDDocumentsDelete(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all unsended documents to which this attachment is append. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDDocumentsGet(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDDocumentsGet(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append this attachment to all documents in the list.</br>The attachement is append at end of the document after already exkisting attachment. 
                    * @param {number} attachmentID 
                    * @param {Array<number>} [doumentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDDocumentsPatch(attachmentID: number, doumentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDDocumentsPatch(attachmentID, doumentIDs, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets referenced attachment. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDGet(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDGet(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced attachment as PDF preview. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDPdfGet(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDPdfGet(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced attachment as PNG preview of the first page. 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsAttachmentIDPngGet(attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsAttachmentIDPngGet(attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all attachment references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsGet(axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Upload an attachment 
                    * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [attachmentData] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof AttachmentsApi
            */
                public attachmentsPost(attachmentData?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: AxiosRequestConfig) {
                return AttachmentsApiFp(this.configuration).attachmentsPost(attachmentData, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * DocumentsApi - axios parameter creator
    * @export
    */
    export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Remove an attachment from the document 
            * @param {number} documentID 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsAttachmentIDDelete: async (documentID: number, attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsAttachmentIDDelete', 'documentID', documentID)
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsAttachmentIDDelete', 'attachmentID', attachmentID)
            const localVarPath = `/documents/{documentID}/attachments/{attachmentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
            * @param {number} documentID 
            * @param {number} attachmentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsAttachmentIDPost: async (documentID: number, attachmentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsAttachmentIDPost', 'documentID', documentID)
                    // verify required parameter 'attachmentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsAttachmentIDPost', 'attachmentID', attachmentID)
            const localVarPath = `/documents/{documentID}/attachments/{attachmentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"attachmentID"}}`, encodeURIComponent(String(attachmentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Detach all attachments of the document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsDelete: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsDelete', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s all attachments 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
            * @param {number} documentID 
            * @param {Array<number>} [attachmentIDs] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsPatch: async (documentID: number, attachmentIDs?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsPatch', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attachmentIDs, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
            * @param {number} documentID 
            * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [appendAttachment] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttachmentsPost: async (documentID: number, appendAttachment?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttachmentsPost', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attachments`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(appendAttachment, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s attributes 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttributesGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attributes`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes an attribute from the document. 
            * @param {number} documentID 
            * @param {string} key 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttributesKeyDelete: async (documentID: number, key: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyDelete', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyDelete', 'key', key)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the document\'s attribute for a specified key. 
            * @param {number} documentID 
            * @param {string} key 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttributesKeyGet: async (documentID: number, key: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyGet', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyGet', 'key', key)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates the document\'s attribute for a specified key. 
            * @param {number} documentID 
            * @param {string} key 
            * @param {string} value 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttributesKeyPut: async (documentID: number, key: string, value: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyPut', 'documentID', documentID)
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyPut', 'key', key)
                    // verify required parameter 'value' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesKeyPut', 'value', value)
            const localVarPath = `/documents/{documentID}/attributes/{key}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
                const localVarFormParams = new URLSearchParams();

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


                        if (value !== undefined) { 
                            localVarFormParams.set('value', value as any);
                        }
            
        
                localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = localVarFormParams.toString();

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Marks the document with certain attributes. 
            * @param {number} documentID 
            * @param {Array<LetterAttribute>} [attributes] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDAttributesPost: async (documentID: number, attributes?: Array<LetterAttribute>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDAttributesPost', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/attributes`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(attributes, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes the cover page from the document. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDCoverpageDelete: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDCoverpageDelete', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/coverpage`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
            * @param {number} documentID 
            * @param {DocumentsDocumentIDCoverpageDeleteRequest} [coverPage] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDCoverpagePut: async (documentID: number, coverPage?: DocumentsDocumentIDCoverpageDeleteRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDCoverpagePut', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/coverpage`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(coverPage, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Deletes the referenced document. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDDelete: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDDelete', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets document\'s options. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDOptionsGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDOptionsGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/options`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Updates document\'s options 
            * @param {number} documentID 
            * @param {Options} [options] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDOptionsPut: async (documentID: number, options?: Options, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDOptionsPut', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/options`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(options, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document as PDF preview. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDPdfGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDPdfGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/pdf`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets the referenced document as PNG preview. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDPngGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDPngGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/png`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of a document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDStatusGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDStatusGet', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/status`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Removes the performed transformation on the document and rolls back to the original version of the document 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDTransformationsDelete: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDTransformationsDelete', 'documentID', documentID)
            const localVarPath = `/documents/{documentID}/transformations`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
            * @param {number} documentID 
            * @param {DocumentsDocumentIDTransformationsDeleteRequest} transformation 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsDocumentIDTransformationsPut: async (documentID: number, transformation: DocumentsDocumentIDTransformationsDeleteRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('documentsDocumentIDTransformationsPut', 'documentID', documentID)
                    // verify required parameter 'transformation' is not null or undefined
                    assertParamExists('documentsDocumentIDTransformationsPut', 'transformation', transformation)
            const localVarPath = `/documents/{documentID}/transformations`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(transformation, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsErrorsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
            * @param {Array<string>} key 
            * @param {Array<string>} value 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsFindbyAttributesGet: async (key: Array<string>, value: Array<string>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'key' is not null or undefined
                    assertParamExists('documentsFindbyAttributesGet', 'key', key)
                    // verify required parameter 'value' is not null or undefined
                    assertParamExists('documentsFindbyAttributesGet', 'value', value)
            const localVarPath = `/documents/findbyAttributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)

                    if (key) {
                            localVarQueryParameter['key'] = key;
                    }

                    if (value) {
                            localVarQueryParameter['value'] = value;
                    }


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
            * @param {DocumentsGetRequest} [upload] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        documentsPost: async (upload?: DocumentsGetRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(upload, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * DocumentsApi - functional programming interface
        * @export
        */
        export const DocumentsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
        return {
            /**
            * Remove an attachment from the document 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsAttachmentIDDelete(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsAttachmentIDDelete(documentID, attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsAttachmentIDPost(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsAttachmentIDPost(documentID, attachmentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Detach all attachments of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsDelete(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsDelete(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s all attachments 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                * @param {number} documentID 
                * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsPatch(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsPatch(documentID, attachmentIDs, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttachmentsPost(documentID: number, appendAttachment?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttachmentsPost(documentID, appendAttachment, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s attributes 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttributesGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LetterAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttributesGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes an attribute from the document. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttributesKeyDelete(documentID: number, key: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttributesKeyDelete(documentID, key, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttributesKeyGet(documentID: number, key: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttributesKeyGet(documentID, key, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
                * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttributesKeyPut(documentID: number, key: string, value: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttributesKeyPut(documentID, key, value, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Marks the document with certain attributes. 
                * @param {number} documentID 
                * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDAttributesPost(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LetterAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDAttributesPost(documentID, attributes, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes the cover page from the document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDCoverpageDelete(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDCoverpageDelete(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                * @param {number} documentID 
                * @param {DocumentsDocumentIDCoverpageDeleteRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDCoverpagePut(documentID: number, coverPage?: DocumentsDocumentIDCoverpageDeleteRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDCoverpagePut(documentID, coverPage, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Deletes the referenced document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDDelete(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDDelete(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets document\'s options. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDOptionsGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDOptionsGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Updates document\'s options 
                * @param {number} documentID 
                * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDOptionsPut(documentID: number, options?: Options, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDOptionsPut(documentID, options, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document as PDF preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDPdfGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDPdfGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets the referenced document as PNG preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDPngGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDPngGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of a document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDStatusGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDStatusGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDTransformationsDelete(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDTransformationsDelete(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                * @param {number} documentID 
                * @param {DocumentsDocumentIDTransformationsDeleteRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsDocumentIDTransformationsPut(documentID: number, transformation: DocumentsDocumentIDTransformationsDeleteRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDocumentIDTransformationsPut(documentID, transformation, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsErrorsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsErrorsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                * @param {Array<string>} key 
                * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsFindbyAttributesGet(key: Array<string>, value: Array<string>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFindbyAttributesGet(key, value, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                * @param {DocumentsGetRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async documentsPost(upload?: DocumentsGetRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsPost(upload, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * DocumentsApi - factory interface
        * @export
        */
        export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = DocumentsApiFp(configuration)
        return {
            /**
            * Remove an attachment from the document 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsAttachmentIDDelete(documentID: number, attachmentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDAttachmentsAttachmentIDDelete(documentID, attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsAttachmentIDPost(documentID: number, attachmentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDAttachmentsAttachmentIDPost(documentID, attachmentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Detach all attachments of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsDelete(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDAttachmentsDelete(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s all attachments 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsGet(documentID: number, axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.documentsDocumentIDAttachmentsGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                * @param {number} documentID 
                * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsPatch(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDAttachmentsPatch(documentID, attachmentIDs, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                * @param {number} documentID 
                * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttachmentsPost(documentID: number, appendAttachment?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.documentsDocumentIDAttachmentsPost(documentID, appendAttachment, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s attributes 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttributesGet(documentID: number, axiosConfig?: any): AxiosPromise<Array<LetterAttribute>> {
            return localVarFp.documentsDocumentIDAttributesGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes an attribute from the document. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttributesKeyDelete(documentID: number, key: string, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.documentsDocumentIDAttributesKeyDelete(documentID, key, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttributesKeyGet(documentID: number, key: string, axiosConfig?: any): AxiosPromise<LetterAttribute> {
            return localVarFp.documentsDocumentIDAttributesKeyGet(documentID, key, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates the document\'s attribute for a specified key. 
                * @param {number} documentID 
                * @param {string} key 
                * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttributesKeyPut(documentID: number, key: string, value: string, axiosConfig?: any): AxiosPromise<LetterAttribute> {
            return localVarFp.documentsDocumentIDAttributesKeyPut(documentID, key, value, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Marks the document with certain attributes. 
                * @param {number} documentID 
                * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDAttributesPost(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: any): AxiosPromise<Array<LetterAttribute>> {
            return localVarFp.documentsDocumentIDAttributesPost(documentID, attributes, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes the cover page from the document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDCoverpageDelete(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.documentsDocumentIDCoverpageDelete(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                * @param {number} documentID 
                * @param {DocumentsDocumentIDCoverpageDeleteRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDCoverpagePut(documentID: number, coverPage?: DocumentsDocumentIDCoverpageDeleteRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDCoverpagePut(documentID, coverPage, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Deletes the referenced document. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDDelete(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.documentsDocumentIDDelete(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDGet(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets document\'s options. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDOptionsGet(documentID: number, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.documentsDocumentIDOptionsGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Updates document\'s options 
                * @param {number} documentID 
                * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDOptionsPut(documentID: number, options?: Options, axiosConfig?: any): AxiosPromise<Options> {
            return localVarFp.documentsDocumentIDOptionsPut(documentID, options, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document as PDF preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDPdfGet(documentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.documentsDocumentIDPdfGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets the referenced document as PNG preview. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDPngGet(documentID: number, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.documentsDocumentIDPngGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of a document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDStatusGet(documentID: number, axiosConfig?: any): AxiosPromise<DocumentStatus> {
            return localVarFp.documentsDocumentIDStatusGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDTransformationsDelete(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.documentsDocumentIDTransformationsDelete(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                * @param {number} documentID 
                * @param {DocumentsDocumentIDTransformationsDeleteRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsDocumentIDTransformationsPut(documentID: number, transformation: DocumentsDocumentIDTransformationsDeleteRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsDocumentIDTransformationsPut(documentID, transformation, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsErrorsGet(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.documentsErrorsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                * @param {Array<string>} key 
                * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsFindbyAttributesGet(key: Array<string>, value: Array<string>, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.documentsFindbyAttributesGet(key, value, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsGet(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.documentsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                * @param {DocumentsGetRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        documentsPost(upload?: DocumentsGetRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.documentsPost(upload, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * DocumentsApi - object-oriented interface
        * @export
        * @class DocumentsApi
        * @extends {BaseAPI}
        */
            export class DocumentsApi extends BaseAPI {
            /**
            * Remove an attachment from the document 
                    * @param {number} documentID 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsAttachmentIDDelete(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsAttachmentIDDelete(documentID, attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                    * @param {number} documentID 
                    * @param {number} attachmentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsAttachmentIDPost(documentID: number, attachmentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsAttachmentIDPost(documentID, attachmentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Detach all attachments of the document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsDelete(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsDelete(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s all attachments 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append a list of attachments to a document.</br>Already appended attachments stay unchanged.</br>The new attachments will be append at the end in order of list. If the order of the attachments is important take care of this.
                    * @param {number} documentID 
                    * @param {Array<number>} [attachmentIDs] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsPatch(documentID: number, attachmentIDs?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsPatch(documentID, attachmentIDs, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Append an Attachment to a document after already appended attachments.</br> The list of all attachments of the document is returned 
                    * @param {number} documentID 
                    * @param {DocumentsDocumentIDAttachmentsDeleteRequest} [appendAttachment] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttachmentsPost(documentID: number, appendAttachment?: DocumentsDocumentIDAttachmentsDeleteRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttachmentsPost(documentID, appendAttachment, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s attributes 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttributesGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttributesGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes an attribute from the document. 
                    * @param {number} documentID 
                    * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttributesKeyDelete(documentID: number, key: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttributesKeyDelete(documentID, key, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the document\'s attribute for a specified key. 
                    * @param {number} documentID 
                    * @param {string} key 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttributesKeyGet(documentID: number, key: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttributesKeyGet(documentID, key, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates the document\'s attribute for a specified key. 
                    * @param {number} documentID 
                    * @param {string} key 
                    * @param {string} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttributesKeyPut(documentID: number, key: string, value: string, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttributesKeyPut(documentID, key, value, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Marks the document with certain attributes. 
                    * @param {number} documentID 
                    * @param {Array<LetterAttribute>} [attributes] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDAttributesPost(documentID: number, attributes?: Array<LetterAttribute>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDAttributesPost(documentID, attributes, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes the cover page from the document. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDCoverpageDelete(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDCoverpageDelete(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Creates a cover page for the document, so a receiving address is obligatory. <br> The return address is optional, also the text on the coverpage below the address. 
                    * @param {number} documentID 
                    * @param {DocumentsDocumentIDCoverpageDeleteRequest} [coverPage] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDCoverpagePut(documentID: number, coverPage?: DocumentsDocumentIDCoverpageDeleteRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDCoverpagePut(documentID, coverPage, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Deletes the referenced document. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDDelete(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDDelete(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document. The document is a letter, a serial letter or an \'error\' object. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets document\'s options. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDOptionsGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDOptionsGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Updates document\'s options 
                    * @param {number} documentID 
                    * @param {Options} [options] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDOptionsPut(documentID: number, options?: Options, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDOptionsPut(documentID, options, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document as PDF preview. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDPdfGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDPdfGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets the referenced document as PNG preview. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDPngGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDPngGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of a document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDStatusGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDStatusGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Removes the performed transformation on the document and rolls back to the original version of the document 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDTransformationsDelete(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDTransformationsDelete(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Applies a transformation of the document\'s first page. <br>  After transformation, the document is validated once more. Therefore, please check the document\'s status again after performing any transformations.   <br>  Every transformation is applied on the original version of the document. <br>  \"offsetX\" and \"offsetY\" affect the horizontal and vertical position, moving the document along the x and y axis, using [mm] as a unit. Starting point is the upper left corner of the page.  <br>   Also scaleX and scaleY can be independently used for scaling. Factor 1 corresponds to 100%, so in order to shrink, use values smaller than 1. Scaling refers to the center of the page.  
                    * @param {number} documentID 
                    * @param {DocumentsDocumentIDTransformationsDeleteRequest} transformation 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsDocumentIDTransformationsPut(documentID: number, transformation: DocumentsDocumentIDTransformationsDeleteRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsDocumentIDTransformationsPut(documentID, transformation, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letter references which are erroneous.  Erroneous documents can have the following status codes:    7 (erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsErrorsGet(axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsErrorsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letters which were marked with the given attributes.<br> There must be at least one pair of the parameters key and value. Take care that of the order of the keys and values.  
                    * @param {Array<string>} key 
                    * @param {Array<string>} value 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsFindbyAttributesGet(key: Array<string>, value: Array<string>, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsFindbyAttributesGet(key, value, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all uploaded letter references which are shippable.  Shippable documents can have the following status codes:    2 (is shippable) <br><br> Optional a filter on attributes can be defined.<br> attributes is a JSON-formated string. <br> This object is an array of LetterAtributte 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsGet(axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Uploads a new document. The document shall be a letter or a serial letter.</br>  The letter contains a valid address in the proper print area and respects the exclusion areas.</br>  The content must be base64 encoded. The document will be validated.</br>  If validation fails, an optional correction (transformation, cover page, address label) will be provided.</br> The response will contain a valid document (letter/serial letter) or an \'error\' object.</br>  The document is normalized with ghostscript, therefore we recommend a visible check of the document with GET /documents/{documentID}/pdf.  The document status can have the following codes:    2 (is shippable),      7 (is erroneous)    
                    * @param {DocumentsGetRequest} [upload] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof DocumentsApi
            */
                public documentsPost(upload?: DocumentsGetRequest, axiosConfig?: AxiosRequestConfig) {
                return DocumentsApiFp(this.configuration).documentsPost(upload, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * InvoicesApi - axios parameter creator
    * @export
    */
    export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Gets all stored invoices references. 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        invoicesGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all transctions of the invoice. 
            * @param {string} invoiceNumber 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        invoicesInvoiceNumberGet: async (invoiceNumber: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'invoiceNumber' is not null or undefined
                    assertParamExists('invoicesInvoiceNumberGet', 'invoiceNumber', invoiceNumber)
            const localVarPath = `/invoices/{invoiceNumber}`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Get a specific invoice as PDF. 
            * @param {string} invoiceNumber 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        invoicesInvoiceNumberPdfGet: async (invoiceNumber: string, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'invoiceNumber' is not null or undefined
                    assertParamExists('invoicesInvoiceNumberPdfGet', 'invoiceNumber', invoiceNumber)
            const localVarPath = `/invoices/{invoiceNumber}/pdf`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * InvoicesApi - functional programming interface
        * @export
        */
        export const InvoicesApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
        return {
            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async invoicesGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all transctions of the invoice. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async invoicesInvoiceNumberGet(invoiceNumber: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesInvoiceNumberGet(invoiceNumber, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Get a specific invoice as PDF. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async invoicesInvoiceNumberPdfGet(invoiceNumber: string, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicesInvoiceNumberPdfGet(invoiceNumber, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * InvoicesApi - factory interface
        * @export
        */
        export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = InvoicesApiFp(configuration)
        return {
            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        invoicesGet(axiosConfig?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.invoicesGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all transctions of the invoice. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        invoicesInvoiceNumberGet(invoiceNumber: string, axiosConfig?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.invoicesInvoiceNumberGet(invoiceNumber, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Get a specific invoice as PDF. 
                * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        invoicesInvoiceNumberPdfGet(invoiceNumber: string, axiosConfig?: any): AxiosPromise<any> {
            return localVarFp.invoicesInvoiceNumberPdfGet(invoiceNumber, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * InvoicesApi - object-oriented interface
        * @export
        * @class InvoicesApi
        * @extends {BaseAPI}
        */
            export class InvoicesApi extends BaseAPI {
            /**
            * Gets all stored invoices references. 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public invoicesGet(axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).invoicesGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all transctions of the invoice. 
                    * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public invoicesInvoiceNumberGet(invoiceNumber: string, axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).invoicesInvoiceNumberGet(invoiceNumber, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Get a specific invoice as PDF. 
                    * @param {string} invoiceNumber 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof InvoicesApi
            */
                public invoicesInvoiceNumberPdfGet(invoiceNumber: string, axiosConfig?: AxiosRequestConfig) {
                return InvoicesApiFp(this.configuration).invoicesInvoiceNumberPdfGet(invoiceNumber, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


    /**
    * SendingsApi - axios parameter creator
    * @export
    */
    export const SendingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
        * Deletes a canceled or a delivered and sent document from the system. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentIDDelete: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('sendingsDocumentIDDelete', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentIDGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('sendingsDocumentIDGet', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Announces the delivery of a letter, if it isn\'t yet shipped. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentIDPost: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('sendingsDocumentIDPost', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Cancels the delivery of a letter, if it isn\'t already shipped. 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentIDPut: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('sendingsDocumentIDPut', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {number} documentID 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentIDStatusGet: async (documentID: number, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
                    // verify required parameter 'documentID' is not null or undefined
                    assertParamExists('sendingsDocumentIDStatusGet', 'documentID', documentID)
            const localVarPath = `/sendings/{documentID}/status`
                .replace(`{${"documentID"}}`, encodeURIComponent(String(documentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Document is directly sent after upload, if it is successfully validated. 
            * @param {SendingsDocumentPostRequest} [shipping] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsDocumentPost: async (shipping?: SendingsDocumentPostRequest, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(shipping, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsGet: async (axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsPost: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(documentIds, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsPut: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)


        
                    localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};
                localVarRequestOptions.data = serializeDataIfNeeded(documentIds, localVarRequestOptions, configuration)

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        /**
        * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {Array<number>} [documentIds] 
        * @param {*} [axiosConfig] Override http request option.
        * @throws {RequiredError}
        */
        sendingsStatusGet: async (documentIds?: Array<number>, axiosConfig: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendings/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
            baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosConfig};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

                // authentication basicAuth required
                    // http basic authentication required
                    setBasicAuthToObject(localVarRequestOptions, configuration)

                    if (documentIds) {
                            localVarQueryParameter['documentIds'] = documentIds;
                    }


        
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosConfig.headers};

            return {
            url: toPathString(localVarUrlObj),
            options: localVarRequestOptions,
            };
            },
        }
        };

        /**
        * SendingsApi - functional programming interface
        * @export
        */
        export const SendingsApiFp = function(configuration?: Configuration) {
        const localVarAxiosParamCreator = SendingsApiAxiosParamCreator(configuration)
        return {
            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentIDDelete(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentIDDelete(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentIDGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentIDGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentIDPost(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentIDPost(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentIDPut(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentIDPut(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentIDStatusGet(documentID: number, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentIDStatusGet(documentID, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Document is directly sent after upload, if it is successfully validated. 
                * @param {SendingsDocumentPostRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsDocumentPost(shipping?: SendingsDocumentPostRequest, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsDocumentPost(shipping, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsGet(axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsGet(axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsPost(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Document>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsPost(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsPut(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsPut(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
            async sendingsStatusGet(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendingsStatusGet(documentIds, axiosConfig);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            },
        }
        };

        /**
        * SendingsApi - factory interface
        * @export
        */
        export const SendingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
        const localVarFp = SendingsApiFp(configuration)
        return {
            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentIDDelete(documentID: number, axiosConfig?: any): AxiosPromise<void> {
            return localVarFp.sendingsDocumentIDDelete(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentIDGet(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.sendingsDocumentIDGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentIDPost(documentID: number, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.sendingsDocumentIDPost(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentIDPut(documentID: number, axiosConfig?: any): AxiosPromise<Status> {
            return localVarFp.sendingsDocumentIDPut(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentIDStatusGet(documentID: number, axiosConfig?: any): AxiosPromise<DocumentStatus> {
            return localVarFp.sendingsDocumentIDStatusGet(documentID, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Document is directly sent after upload, if it is successfully validated. 
                * @param {SendingsDocumentPostRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsDocumentPost(shipping?: SendingsDocumentPostRequest, axiosConfig?: any): AxiosPromise<Document> {
            return localVarFp.sendingsDocumentPost(shipping, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsGet(axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.sendingsGet(axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsPost(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<Document>> {
            return localVarFp.sendingsPost(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsPut(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.sendingsPut(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            */
        sendingsStatusGet(documentIds?: Array<number>, axiosConfig?: any): AxiosPromise<Array<DocumentStatus>> {
            return localVarFp.sendingsStatusGet(documentIds, axiosConfig).then((request) => request(axios, basePath));
            },
        };
        };

        /**
        * SendingsApi - object-oriented interface
        * @export
        * @class SendingsApi
        * @extends {BaseAPI}
        */
            export class SendingsApi extends BaseAPI {
            /**
            * Deletes a canceled or a delivered and sent document from the system. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentIDDelete(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentIDDelete(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets a referenced sending. The sending is a letter, serial letter or an \'error\' object. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentIDGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentIDGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Announces the delivery of a letter, if it isn\'t yet shipped. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentIDPost(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentIDPost(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Cancels the delivery of a letter, if it isn\'t already shipped. 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentIDPut(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentIDPut(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of a document, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                    * @param {number} documentID 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentIDStatusGet(documentID: number, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentIDStatusGet(documentID, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Document is directly sent after upload, if it is successfully validated. 
                    * @param {SendingsDocumentPostRequest} [shipping] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsDocumentPost(shipping?: SendingsDocumentPostRequest, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsDocumentPost(shipping, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets all document references, which are prepared for delivering or are already delivered.  Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsGet(axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsGet(axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Announces a letter (its ID) or a list of letters (list of IDs) which are already uploaded for delivering. 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsPost(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsPost(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Cancels the delivery of a list of letters (list of IDs). Only not shipped letters  are canceled.  . 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsPut(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsPut(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }

            /**
            * Gets status of all documents, which are prepared for delivering or are already delivered.   The Query can be optional narrowed with a list of DocumentIds.   Sendings can have the following status codes:       3 (in production, waiting to be sent),        4 (in print process),        5 (is sent),        6 (is canceled),        7 (is erroneous) 
                    * @param {Array<number>} [documentIds] 
            * @param {*} [axiosConfig] Override http request option.
            * @throws {RequiredError}
            * @memberof SendingsApi
            */
                public sendingsStatusGet(documentIds?: Array<number>, axiosConfig?: AxiosRequestConfig) {
                return SendingsApiFp(this.configuration).sendingsStatusGet(documentIds, axiosConfig).then((request) => request(this.axios, this.basePath));
                }
        }


